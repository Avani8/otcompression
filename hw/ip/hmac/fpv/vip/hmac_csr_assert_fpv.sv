// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// FPV CSR read and write assertions auto-generated by `reggen` containing data structure
// Do Not Edit directly


// Block: hmac
module hmac_csr_assert_fpv import tlul_pkg::*; (
  input clk_i,
  input rst_ni,

  //tile link ports
  input tl_h2d_t h2d,
  input tl_d2h_t d2h
);

  // mask register to convert byte to bit
  logic [31:0] a_mask_bit;

  assign a_mask_bit[7:0]   = h2d.a_mask[0] ? '1 : '0;
  assign a_mask_bit[15:8]  = h2d.a_mask[1] ? '1 : '0;
  assign a_mask_bit[23:16] = h2d.a_mask[2] ? '1 : '0;
  assign a_mask_bit[31:24] = h2d.a_mask[3] ? '1 : '0;

  // declare common read and write sequences
  sequence device_wr_S(logic [11:0] addr);
    h2d.a_address == addr && h2d.a_opcode inside {PutFullData, PutPartialData} && h2d.a_valid && h2d.d_ready && !d2h.d_valid;
  endsequence

  sequence device_rd_S(logic [11:0] addr);
    h2d.a_address == addr && h2d.a_opcode inside {Get} && h2d.a_valid && h2d.d_ready && !d2h.d_valid;
  endsequence

  // declare common read and write properties
  property wr_P(int width, bit [11:0] addr, bit [31:0] compare_data, bit regen = 1);
    logic [31:0] id;
    logic [width:0] data;
    (device_wr_S(addr),id = h2d.a_source, data = h2d.a_data & a_mask_bit) |->
        strong(##[1:$] (d2h.d_valid && d2h.d_source == id && (d2h.d_error ||
        (!d2h.d_error && compare_data == data) || !regen)));
  endproperty

  property wr_ext_P(int width, bit [11:0] addr, bit [31:0] compare_data, bit regen = 1);
    logic [31:0] id;
    logic [width:0] data;
    logic [width:0] compare_value;
    (device_wr_S(addr),id = h2d.a_source, data = h2d.a_data & a_mask_bit,
        compare_value = compare_data) |->
        strong(##[1:$] (d2h.d_valid && d2h.d_source == id && (d2h.d_error ||
        (!d2h.d_error && compare_value == data) || !regen)));
  endproperty

  property rd_P(int width, bit [11:0] addr, bit [31:0] compare_data);
    logic [31:0] id;
    logic [width:0] data;
    (device_rd_S(addr), id = h2d.a_source, data = $past(compare_data)) |->
        strong(##[1:$] (d2h.d_valid && d2h.d_source == id && (d2h.d_error ||
        (!d2h.d_error && d2h.d_data == data))));
  endproperty

  property rd_ext_P(int width, bit [11:0] addr, bit [31:0] compare_data);
    logic [31:0] id;
    logic [width:0] data;
    (device_rd_S(addr), id = h2d.a_source, data = compare_data) |->
        strong(##[1:$] (d2h.d_valid && d2h.d_source == id && (d2h.d_error ||
        (!d2h.d_error && d2h.d_data == data))));
  endproperty

  property wr_regen_stable_P(regen, compare_data);
    (!regen && $stable(regen)) |-> $stable(compare_data);
  endproperty

// for all the regsters, declare assertion

  // read/write assertions for register: intr_state
  `ASSERT(intr_state_wr_A, wr_P(2, 12'h0, i_hmac.reg2hw.intr_state.q, 0), clk_i, !rst_ni)
  `ASSERT(intr_state_rd_A, rd_P(2, 12'h0, i_hmac.hw2reg.intr_state.d), clk_i, !rst_ni)

  // read/write assertions for register: intr_enable
  `ASSERT(intr_enable_wr_A, wr_P(2, 12'h4, i_hmac.reg2hw.intr_enable.q, 0), clk_i, !rst_ni)
  `ASSERT(intr_enable_rd_A, rd_P(2, 12'h4, i_hmac.reg2hw.intr_enable.q), clk_i, !rst_ni)

  // read/write assertions for register: intr_test
  `ASSERT(intr_test_wr_A, wr_ext_P(2, 12'h8, i_hmac.reg2hw.intr_test.q, 0), clk_i, !rst_ni)

  // read/write assertions for register: cfg
  `ASSERT(cfg_wr_A, wr_ext_P(3, 12'hc, i_hmac.reg2hw.cfg.q, 0), clk_i, !rst_ni)
  `ASSERT(cfg_rd_A, rd_ext_P(3, 12'hc, i_hmac.hw2reg.cfg.d), clk_i, !rst_ni)

  // read/write assertions for register: cmd
  `ASSERT(cmd_wr_A, wr_ext_P(1, 12'h10, i_hmac.reg2hw.cmd.q, 0), clk_i, !rst_ni)
  `ASSERT(cmd_rd_A, rd_ext_P(1, 12'h10, i_hmac.reg2hw.cmd.q), clk_i, !rst_ni)

  // read/write assertions for register: status
  `ASSERT(status_rd_A, rd_ext_P(8, 12'h14, i_hmac.hw2reg.status.d), clk_i, !rst_ni)

  // read/write assertions for register: err_code
  `ASSERT(err_code_rd_A, rd_P(31, 12'h18, i_hmac.hw2reg.err_code.d), clk_i, !rst_ni)

  // read/write assertions for register: wipe_secret
  `ASSERT(wipe_secret_wr_A, wr_ext_P(31, 12'h1c, i_hmac.reg2hw.wipe_secret.q, 0), clk_i, !rst_ni)

  // define local fpv variable for the multi_reg
  logic [255:0] key_q_fpv;
  for (genvar s = 0; s <= 8-1; s++) begin : gen_key_rd
    assign key_q_fpv[((s+1)*32-1):s*32] = i_hmac.reg2hw.key[s].q;
  end
  logic [255:0] key_d_fpv;
  for (genvar s = 0; s <= 8-1; s++) begin : gen_key_wr
    assign key_d_fpv[(s*32-1):s] = i_hmac.hw2reg.key[s].d;
  end

  // read/write assertions for register: key0
  `ASSERT(key0_wr_A, wr_ext_P(31, 12'h20, key_q_fpv[31:0], 0), clk_i, !rst_ni)

  // read/write assertions for register: key1
  `ASSERT(key1_wr_A, wr_ext_P(31, 12'h24, key_q_fpv[63:32], 0), clk_i, !rst_ni)

  // read/write assertions for register: key2
  `ASSERT(key2_wr_A, wr_ext_P(31, 12'h28, key_q_fpv[95:64], 0), clk_i, !rst_ni)

  // read/write assertions for register: key3
  `ASSERT(key3_wr_A, wr_ext_P(31, 12'h2c, key_q_fpv[127:96], 0), clk_i, !rst_ni)

  // read/write assertions for register: key4
  `ASSERT(key4_wr_A, wr_ext_P(31, 12'h30, key_q_fpv[159:128], 0), clk_i, !rst_ni)

  // read/write assertions for register: key5
  `ASSERT(key5_wr_A, wr_ext_P(31, 12'h34, key_q_fpv[191:160], 0), clk_i, !rst_ni)

  // read/write assertions for register: key6
  `ASSERT(key6_wr_A, wr_ext_P(31, 12'h38, key_q_fpv[223:192], 0), clk_i, !rst_ni)

  // read/write assertions for register: key7
  `ASSERT(key7_wr_A, wr_ext_P(31, 12'h3c, key_q_fpv[255:224], 0), clk_i, !rst_ni)

  // define local fpv variable for the multi_reg
  logic [255:0] digest_d_fpv;
  for (genvar s = 0; s <= 8-1; s++) begin : gen_digest_wr
    assign digest_d_fpv[(s*32-1):s] = i_hmac.hw2reg.digest[s].d;
  end

  // read/write assertions for register: digest0
  `ASSERT(digest0_rd_A, rd_ext_P(31, 12'h40, digest_d_fpv[31:0]), clk_i, !rst_ni)

  // read/write assertions for register: digest1
  `ASSERT(digest1_rd_A, rd_ext_P(31, 12'h44, digest_d_fpv[63:32]), clk_i, !rst_ni)

  // read/write assertions for register: digest2
  `ASSERT(digest2_rd_A, rd_ext_P(31, 12'h48, digest_d_fpv[95:64]), clk_i, !rst_ni)

  // read/write assertions for register: digest3
  `ASSERT(digest3_rd_A, rd_ext_P(31, 12'h4c, digest_d_fpv[127:96]), clk_i, !rst_ni)

  // read/write assertions for register: digest4
  `ASSERT(digest4_rd_A, rd_ext_P(31, 12'h50, digest_d_fpv[159:128]), clk_i, !rst_ni)

  // read/write assertions for register: digest5
  `ASSERT(digest5_rd_A, rd_ext_P(31, 12'h54, digest_d_fpv[191:160]), clk_i, !rst_ni)

  // read/write assertions for register: digest6
  `ASSERT(digest6_rd_A, rd_ext_P(31, 12'h58, digest_d_fpv[223:192]), clk_i, !rst_ni)

  // read/write assertions for register: digest7
  `ASSERT(digest7_rd_A, rd_ext_P(31, 12'h5c, digest_d_fpv[255:224]), clk_i, !rst_ni)

  // read/write assertions for register: msg_length_lower
  `ASSERT(msg_length_lower_rd_A, rd_P(31, 12'h60, i_hmac.hw2reg.msg_length_lower.d), clk_i, !rst_ni)

  // read/write assertions for register: msg_length_upper
  `ASSERT(msg_length_upper_rd_A, rd_P(31, 12'h64, i_hmac.hw2reg.msg_length_upper.d), clk_i, !rst_ni)

endmodule
