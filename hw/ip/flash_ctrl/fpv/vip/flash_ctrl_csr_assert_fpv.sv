// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// FPV CSR read and write assertions auto-generated by `reggen` containing data structure
// Do Not Edit directly


// Block: flash_ctrl
module flash_ctrl_csr_assert_fpv import tlul_pkg::*; (
  input clk_i,
  input rst_ni,

  //tile link ports
  input tl_h2d_t h2d,
  input tl_d2h_t d2h
);

  // mask register to convert byte to bit
  logic [31:0] a_mask_bit;

  assign a_mask_bit[7:0]   = h2d.a_mask[0] ? '1 : '0;
  assign a_mask_bit[15:8]  = h2d.a_mask[1] ? '1 : '0;
  assign a_mask_bit[23:16] = h2d.a_mask[2] ? '1 : '0;
  assign a_mask_bit[31:24] = h2d.a_mask[3] ? '1 : '0;

  // declare common read and write sequences
  sequence device_wr_S(logic [6:0] addr);
    h2d.a_address == addr && h2d.a_opcode inside {PutFullData, PutPartialData} && h2d.a_valid && h2d.d_ready && !d2h.d_valid;
  endsequence

  sequence device_rd_S(logic [6:0] addr);
    h2d.a_address == addr && h2d.a_opcode inside {Get} && h2d.a_valid && h2d.d_ready && !d2h.d_valid;
  endsequence

  // declare common read and write properties
  property wr_P(int width, bit [6:0] addr, bit [31:0] compare_data, bit regen = 1);
    logic [31:0] id;
    logic [width:0] data;
    (device_wr_S(addr),id = h2d.a_source, data = h2d.a_data & a_mask_bit) |->
        strong(##[1:$] (d2h.d_valid && d2h.d_source == id && (d2h.d_error ||
        (!d2h.d_error && compare_data == data) || !regen)));
  endproperty

  property wr_ext_P(int width, bit [6:0] addr, bit [31:0] compare_data, bit regen = 1);
    logic [31:0] id;
    logic [width:0] data;
    logic [width:0] compare_value;
    (device_wr_S(addr),id = h2d.a_source, data = h2d.a_data & a_mask_bit,
        compare_value = compare_data) |->
        strong(##[1:$] (d2h.d_valid && d2h.d_source == id && (d2h.d_error ||
        (!d2h.d_error && compare_value == data) || !regen)));
  endproperty

  property rd_P(int width, bit [6:0] addr, bit [31:0] compare_data);
    logic [31:0] id;
    logic [width:0] data;
    (device_rd_S(addr), id = h2d.a_source, data = $past(compare_data)) |->
        strong(##[1:$] (d2h.d_valid && d2h.d_source == id && (d2h.d_error ||
        (!d2h.d_error && d2h.d_data == data))));
  endproperty

  property rd_ext_P(int width, bit [6:0] addr, bit [31:0] compare_data);
    logic [31:0] id;
    logic [width:0] data;
    (device_rd_S(addr), id = h2d.a_source, data = compare_data) |->
        strong(##[1:$] (d2h.d_valid && d2h.d_source == id && (d2h.d_error ||
        (!d2h.d_error && d2h.d_data == data))));
  endproperty

  property wr_regen_stable_P(regen, compare_data);
    (!regen && $stable(regen)) |-> $stable(compare_data);
  endproperty

// for all the regsters, declare assertion

  // read/write assertions for register: intr_state
  `ASSERT(intr_state_wr_A, wr_P(5, 7'h0, i_flash_ctrl.reg2hw.intr_state.q, 0), clk_i, !rst_ni)
  `ASSERT(intr_state_rd_A, rd_P(5, 7'h0, i_flash_ctrl.hw2reg.intr_state.d), clk_i, !rst_ni)

  // read/write assertions for register: intr_enable
  `ASSERT(intr_enable_wr_A, wr_P(5, 7'h4, i_flash_ctrl.reg2hw.intr_enable.q, 0), clk_i, !rst_ni)
  `ASSERT(intr_enable_rd_A, rd_P(5, 7'h4, i_flash_ctrl.reg2hw.intr_enable.q), clk_i, !rst_ni)

  // read/write assertions for register: intr_test
  `ASSERT(intr_test_wr_A, wr_ext_P(5, 7'h8, i_flash_ctrl.reg2hw.intr_test.q, 0), clk_i, !rst_ni)

  // read/write assertions for register: control
  `ASSERT(control_wr_A, wr_P(27, 7'hc, i_flash_ctrl.reg2hw.control.q, 0), clk_i, !rst_ni)
  `ASSERT(control_rd_A, rd_P(27, 7'hc, i_flash_ctrl.hw2reg.control.d), clk_i, !rst_ni)

  // read/write assertions for register: addr
  `ASSERT(addr_wr_A, wr_P(31, 7'h10, i_flash_ctrl.reg2hw.addr.q, 0), clk_i, !rst_ni)
  `ASSERT(addr_rd_A, rd_P(31, 7'h10, i_flash_ctrl.reg2hw.addr.q), clk_i, !rst_ni)

  // define local fpv variable for the multi_reg

  // read/write assertions for register: region_cfg_regwen
  `ASSERT(region_cfg_regwen_wr_A, wr_P(7, 7'h14, i_flash_ctrl.i_reg_top.region_cfg_regwen_we, 0), clk_i, !rst_ni)
  `ASSERT(region_cfg_regwen_rd_A, rd_P(7, 7'h14, i_flash_ctrl.i_reg_top.region_cfg_regwen_qs), clk_i, !rst_ni)

  // define local fpv variable for the multi_reg
  logic [47:0] mp_region_cfg_q_fpv;
  for (genvar s = 0; s <= 47; s++) begin : gen_mp_region_cfg_rd
    assign mp_region_cfg_q_fpv[s] = i_flash_ctrl.reg2hw.mp_region_cfg[s].q;
  end

  // read/write assertions for register: mp_region_cfg0
  `ASSERT(mp_region_cfg0_wr_A, wr_P(24, 7'h18, mp_region_cfg_q_fpv[24:0], i_flash_ctrl.i_reg_top.region_cfg_regwen_region0_qs), clk_i, !rst_ni)
  `ASSERT(mp_region_cfg0_stable_A, wr_regen_stable_P(i_flash_ctrl.i_reg_top.region_cfg_regwen_region0_qs, mp_region_cfg_q_fpv[24:0]), clk_i, !rst_ni)
  `ASSERT(mp_region_cfg0_rd_A, rd_P(24, 7'h18, mp_region_cfg_q_fpv[24:0]), clk_i, !rst_ni)

  // read/write assertions for register: mp_region_cfg1
  `ASSERT(mp_region_cfg1_wr_A, wr_P(24, 7'h1c, mp_region_cfg_q_fpv[49:25], i_flash_ctrl.i_reg_top.region_cfg_regwen_region1_qs), clk_i, !rst_ni)
  `ASSERT(mp_region_cfg1_stable_A, wr_regen_stable_P(i_flash_ctrl.i_reg_top.region_cfg_regwen_region1_qs, mp_region_cfg_q_fpv[49:25]), clk_i, !rst_ni)
  `ASSERT(mp_region_cfg1_rd_A, rd_P(24, 7'h1c, mp_region_cfg_q_fpv[49:25]), clk_i, !rst_ni)

  // read/write assertions for register: mp_region_cfg2
  `ASSERT(mp_region_cfg2_wr_A, wr_P(24, 7'h20, mp_region_cfg_q_fpv[74:50], i_flash_ctrl.i_reg_top.region_cfg_regwen_region2_qs), clk_i, !rst_ni)
  `ASSERT(mp_region_cfg2_stable_A, wr_regen_stable_P(i_flash_ctrl.i_reg_top.region_cfg_regwen_region2_qs, mp_region_cfg_q_fpv[74:50]), clk_i, !rst_ni)
  `ASSERT(mp_region_cfg2_rd_A, rd_P(24, 7'h20, mp_region_cfg_q_fpv[74:50]), clk_i, !rst_ni)

  // read/write assertions for register: mp_region_cfg3
  `ASSERT(mp_region_cfg3_wr_A, wr_P(24, 7'h24, mp_region_cfg_q_fpv[99:75], i_flash_ctrl.i_reg_top.region_cfg_regwen_region3_qs), clk_i, !rst_ni)
  `ASSERT(mp_region_cfg3_stable_A, wr_regen_stable_P(i_flash_ctrl.i_reg_top.region_cfg_regwen_region3_qs, mp_region_cfg_q_fpv[99:75]), clk_i, !rst_ni)
  `ASSERT(mp_region_cfg3_rd_A, rd_P(24, 7'h24, mp_region_cfg_q_fpv[99:75]), clk_i, !rst_ni)

  // read/write assertions for register: mp_region_cfg4
  `ASSERT(mp_region_cfg4_wr_A, wr_P(24, 7'h28, mp_region_cfg_q_fpv[124:100], i_flash_ctrl.i_reg_top.region_cfg_regwen_region4_qs), clk_i, !rst_ni)
  `ASSERT(mp_region_cfg4_stable_A, wr_regen_stable_P(i_flash_ctrl.i_reg_top.region_cfg_regwen_region4_qs, mp_region_cfg_q_fpv[124:100]), clk_i, !rst_ni)
  `ASSERT(mp_region_cfg4_rd_A, rd_P(24, 7'h28, mp_region_cfg_q_fpv[124:100]), clk_i, !rst_ni)

  // read/write assertions for register: mp_region_cfg5
  `ASSERT(mp_region_cfg5_wr_A, wr_P(24, 7'h2c, mp_region_cfg_q_fpv[149:125], i_flash_ctrl.i_reg_top.region_cfg_regwen_region5_qs), clk_i, !rst_ni)
  `ASSERT(mp_region_cfg5_stable_A, wr_regen_stable_P(i_flash_ctrl.i_reg_top.region_cfg_regwen_region5_qs, mp_region_cfg_q_fpv[149:125]), clk_i, !rst_ni)
  `ASSERT(mp_region_cfg5_rd_A, rd_P(24, 7'h2c, mp_region_cfg_q_fpv[149:125]), clk_i, !rst_ni)

  // read/write assertions for register: mp_region_cfg6
  `ASSERT(mp_region_cfg6_wr_A, wr_P(24, 7'h30, mp_region_cfg_q_fpv[174:150], i_flash_ctrl.i_reg_top.region_cfg_regwen_region6_qs), clk_i, !rst_ni)
  `ASSERT(mp_region_cfg6_stable_A, wr_regen_stable_P(i_flash_ctrl.i_reg_top.region_cfg_regwen_region6_qs, mp_region_cfg_q_fpv[174:150]), clk_i, !rst_ni)
  `ASSERT(mp_region_cfg6_rd_A, rd_P(24, 7'h30, mp_region_cfg_q_fpv[174:150]), clk_i, !rst_ni)

  // read/write assertions for register: mp_region_cfg7
  `ASSERT(mp_region_cfg7_wr_A, wr_P(24, 7'h34, mp_region_cfg_q_fpv[199:175], i_flash_ctrl.i_reg_top.region_cfg_regwen_region7_qs), clk_i, !rst_ni)
  `ASSERT(mp_region_cfg7_stable_A, wr_regen_stable_P(i_flash_ctrl.i_reg_top.region_cfg_regwen_region7_qs, mp_region_cfg_q_fpv[199:175]), clk_i, !rst_ni)
  `ASSERT(mp_region_cfg7_rd_A, rd_P(24, 7'h34, mp_region_cfg_q_fpv[199:175]), clk_i, !rst_ni)

  // read/write assertions for register: default_region
  `ASSERT(default_region_wr_A, wr_P(2, 7'h38, i_flash_ctrl.reg2hw.default_region.q, 0), clk_i, !rst_ni)
  `ASSERT(default_region_rd_A, rd_P(2, 7'h38, i_flash_ctrl.reg2hw.default_region.q), clk_i, !rst_ni)

  // read/write assertions for register: bank_cfg_regwen
  `ASSERT(bank_cfg_regwen_wr_A, wr_P(0, 7'h3c, i_flash_ctrl.i_reg_top.bank_cfg_regwen_we, 0), clk_i, !rst_ni)
  `ASSERT(bank_cfg_regwen_rd_A, rd_P(0, 7'h3c, i_flash_ctrl.i_reg_top.bank_cfg_regwen_qs), clk_i, !rst_ni)

  // define local fpv variable for the multi_reg
  logic [1:0] mp_bank_cfg_q_fpv;
  for (genvar s = 0; s <= 1; s++) begin : gen_mp_bank_cfg_rd
    assign mp_bank_cfg_q_fpv[s] = i_flash_ctrl.reg2hw.mp_bank_cfg[s].q;
  end

  // read/write assertions for register: mp_bank_cfg
  `ASSERT(mp_bank_cfg_wr_A, wr_P(1, 7'h40, mp_bank_cfg_q_fpv[1:0], i_flash_ctrl.i_reg_top.bank_cfg_regwen_qs), clk_i, !rst_ni)
  `ASSERT(mp_bank_cfg_stable_A, wr_regen_stable_P(i_flash_ctrl.i_reg_top.bank_cfg_regwen_qs, mp_bank_cfg_q_fpv[1:0]), clk_i, !rst_ni)
  `ASSERT(mp_bank_cfg_rd_A, rd_P(1, 7'h40, mp_bank_cfg_q_fpv[1:0]), clk_i, !rst_ni)

  // read/write assertions for register: op_status
  `ASSERT(op_status_wr_A, wr_P(1, 7'h44, i_flash_ctrl.reg2hw.op_status.q, 0), clk_i, !rst_ni)
  `ASSERT(op_status_rd_A, rd_P(1, 7'h44, i_flash_ctrl.hw2reg.op_status.d), clk_i, !rst_ni)

  // read/write assertions for register: status
  `ASSERT(status_rd_A, rd_ext_P(17, 7'h48, i_flash_ctrl.hw2reg.status.d), clk_i, !rst_ni)

  // read/write assertions for register: scratch
  `ASSERT(scratch_wr_A, wr_P(31, 7'h4c, i_flash_ctrl.reg2hw.scratch.q, 0), clk_i, !rst_ni)
  `ASSERT(scratch_rd_A, rd_P(31, 7'h4c, i_flash_ctrl.reg2hw.scratch.q), clk_i, !rst_ni)

  // read/write assertions for register: fifo_lvl
  `ASSERT(fifo_lvl_wr_A, wr_P(12, 7'h50, i_flash_ctrl.reg2hw.fifo_lvl.q, 0), clk_i, !rst_ni)
  `ASSERT(fifo_lvl_rd_A, rd_P(12, 7'h50, i_flash_ctrl.reg2hw.fifo_lvl.q), clk_i, !rst_ni)

endmodule
